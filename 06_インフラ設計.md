# トラック配送計画・配送実績追跡システム - インフラ設計書

## 1. インフラ概要

### 1.1 インフラ設計方針

- **クラウドネイティブ**: コンテナベースのマイクロサービスアーキテクチャ
- **高可用性**: 99.5%以上の稼働率を保証
- **スケーラビリティ**: トラフィック増加に応じた自動スケーリング
- **セキュリティ**: 多層防御によるセキュリティ確保
- **コスト最適化**: 使用量ベースの料金体系とリソース最適化
- **Infrastructure as Code**: Terraform/CDKによる環境構築の自動化

### 1.2 クラウドプロバイダ選定

本設計書では **AWS（Amazon Web Services）** を主軸とし、Azure代替案も併記します。

**選定理由**
- 豊富なマネージドサービス
- グローバルなインフラと高い可用性
- 充実したドキュメントとコミュニティサポート
- コスト最適化ツールの充実

## 2. ネットワーク設計

### 2.1 VPC（Virtual Private Cloud）設計

```
┌─────────────────────────────────────────────────────────────────┐
│                        AWS VPC (10.0.0.0/16)                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              Public Subnet (Multi-AZ)                     │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │  AZ-1a (10.0.1.0/24)          AZ-1c (10.0.2.0/24)        │  │
│  │  ┌──────────────────┐         ┌──────────────────┐      │  │
│  │  │ NAT Gateway      │         │ NAT Gateway      │      │  │
│  │  │ ALB              │         │ ALB              │      │  │
│  │  │ Bastion Host     │         │                  │      │  │
│  │  └──────────────────┘         └──────────────────┘      │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │            Private Subnet - Application                   │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │  AZ-1a (10.0.11.0/24)         AZ-1c (10.0.12.0/24)       │  │
│  │  ┌──────────────────┐         ┌──────────────────┐      │  │
│  │  │ EKS Node         │         │ EKS Node         │      │  │
│  │  │ App Containers   │         │ App Containers   │      │  │
│  │  └──────────────────┘         └──────────────────┘      │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │            Private Subnet - Database                      │  │
│  ├──────────────────────────────────────────────────────────┤  │
│  │  AZ-1a (10.0.21.0/24)         AZ-1c (10.0.22.0/24)       │  │
│  │  ┌──────────────────┐         ┌──────────────────┐      │  │
│  │  │ RDS Primary      │◄────────│ RDS Standby      │      │  │
│  │  │ ElastiCache      │         │ ElastiCache      │      │  │
│  │  │ DocumentDB       │         │ DocumentDB       │      │  │
│  │  └──────────────────┘         └──────────────────┘      │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 サブネット構成

| サブネット種別 | 用途 | CIDR | AZ配置 |
|--------------|------|------|--------|
| Public Subnet | ALB, NAT Gateway, Bastion | 10.0.1.0/24, 10.0.2.0/24 | Multi-AZ |
| Private Subnet (App) | EKSワーカーノード、アプリケーション | 10.0.11.0/24, 10.0.12.0/24 | Multi-AZ |
| Private Subnet (DB) | RDS, ElastiCache, DocumentDB | 10.0.21.0/24, 10.0.22.0/24 | Multi-AZ |

### 2.3 セキュリティグループ設計

**ALB セキュリティグループ**
```
Inbound:
  - Port 443 (HTTPS): 0.0.0.0/0
  - Port 80 (HTTP): 0.0.0.0/0 (HTTPSへリダイレクト)

Outbound:
  - All traffic: 10.0.0.0/16
```

**アプリケーション セキュリティグループ**
```
Inbound:
  - Port 3000: ALB セキュリティグループ
  - Port 8080: ALB セキュリティグループ

Outbound:
  - All traffic: 0.0.0.0/0
```

**データベース セキュリティグループ**
```
Inbound:
  - Port 5432 (PostgreSQL): アプリケーション SG
  - Port 6379 (Redis): アプリケーション SG
  - Port 27017 (MongoDB): アプリケーション SG

Outbound:
  - None
```

## 3. コンピューティング設計

### 3.1 Kubernetes (EKS) 構成

**EKSクラスタ仕様**
```yaml
cluster_name: delivery-system-prod
kubernetes_version: 1.28
region: ap-northeast-1
availability_zones:
  - ap-northeast-1a
  - ap-northeast-1c
```

**ノードグループ構成**

| ノードグループ | インスタンスタイプ | 最小/最大ノード数 | 用途 |
|--------------|-------------------|-----------------|------|
| app-general | t3.medium | 2 / 10 | 一般アプリケーション |
| app-cpu | c5.large | 1 / 5 | CPU集約型処理 |

## 4. データストア設計

### 4.1 RDS (PostgreSQL) 構成

**インスタンス仕様**
```
エンジン: PostgreSQL 16.1
インスタンスクラス: db.r6g.xlarge
vCPU: 4
メモリ: 32GB
ストレージ: 500GB gp3
Multi-AZ: 有効
自動バックアップ: 7日間保持
```

### 4.2 ElastiCache (Redis) 構成

**クラスタ仕様**
```
エンジン: Redis 7.0
ノードタイプ: cache.r6g.large
ノード数: 3 (1 Primary + 2 Replica)
Multi-AZ: 有効
```

### 4.3 DocumentDB (MongoDB互換) 構成

**クラスタ仕様**
```
エンジン: DocumentDB 5.0
インスタンスクラス: db.r6g.large
インスタンス数: 3
バックアップ保持期間: 7日間
```

## 5. 監視・ログ設計

### 5.1 CloudWatch 監視

**主要メトリクス**

| リソース | メトリクス | 閾値 | アクション |
|---------|-----------|------|-----------|
| ALB | TargetResponseTime | > 3秒 | SNS通知 |
| EKS | CPU Utilization | > 80% | Auto Scaling |
| RDS | CPUUtilization | > 80% | SNS通知 |

### 5.2 ログ管理

**ログ保持期間**
```
アプリケーションログ: 30日間
データベースログ: 7日間
アクセスログ: 90日間
監査ログ: 7年間
```

## 6. セキュリティ設計

### 6.1 暗号化

**保存時の暗号化**
- RDS: AWS KMS
- ElastiCache: AWS KMS
- DocumentDB: AWS KMS
- S3: SSE-S3 / SSE-KMS

**転送時の暗号化**
- ALB: TLS 1.2以上
- 全データベース: SSL/TLS必須

### 6.2 IAM・権限管理

- 最小権限の原則
- MFA必須
- IRSA (IAM Roles for Service Accounts)

## 7. バックアップ・DR

### 7.1 バックアップ戦略

**RPO/RTO目標**
```
RPO: 1時間
RTO: 4時間
```

**バックアップスケジュール**
- 日次: 毎日3:00 JST
- 保持期間: 30日間
- 週次: 毎週日曜、90日間保持

## 8. CI/CD インフラ

### 8.1 デプロイパイプライン

- GitHub Actions
- ECR (Container Registry)
- Blue-Green Deployment
- カナリアリリース対応

## 9. コスト設計

### 9.1 月額コスト見積もり

| サービス | 月額概算 (USD) |
|---------|---------------|
| EKS | $73 |
| EC2 (ノード) | $75 |
| RDS | $650 |
| ElastiCache | $390 |
| DocumentDB | $600 |
| その他 | $250 |
| **合計** | **約 $2,038** |

### 9.2 コスト最適化

- リザーブドインスタンス活用
- Spotインスタンス活用
- 自動スケーリング
- データライフサイクル管理

## 10. 開発環境インフラ構成

### 10.1 開発環境の選択肢

開発環境では、コスト効率とセットアップの容易さを重視し、以下の選択肢を提供します。

#### オプション1: ローカル開発環境（推奨）

**Docker Compose構成**

開発者個人のPC上で完結する環境。最もコスト効率が高く、ネットワーク不要で開発可能。

**システム要件**
```
OS: Windows 10/11, macOS 12+, Ubuntu 20.04+
CPU: 4コア以上
メモリ: 16GB以上
ストレージ: 50GB以上の空き容量
Docker Desktop: 最新版
```

**docker-compose.yml 構成**
```yaml
version: '3.8'

services:
  # PostgreSQL
  postgres:
    image: postgis/postgis:16-3.4
    container_name: delivery-postgres
    environment:
      POSTGRES_DB: delivery_dev
      POSTGRES_USER: devuser
      POSTGRES_PASSWORD: devpass
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init:/docker-entrypoint-initdb.d
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U devuser -d delivery_dev"]
      interval: 10s
      timeout: 5s
      retries: 5

  # Redis
  redis:
    image: redis:7-alpine
    container_name: delivery-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 3

  # MongoDB
  mongodb:
    image: mongo:7
    container_name: delivery-mongodb
    environment:
      MONGO_INITDB_ROOT_USERNAME: devuser
      MONGO_INITDB_ROOT_PASSWORD: devpass
      MONGO_INITDB_DATABASE: delivery_dev
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
      interval: 10s
      timeout: 5s
      retries: 3

  # Backend API
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.dev
    container_name: delivery-backend
    environment:
      NODE_ENV: development
      DATABASE_URL: postgresql://devuser:devpass@postgres:5432/delivery_dev
      REDIS_URL: redis://redis:6379
      MONGODB_URL: mongodb://devuser:devpass@mongodb:27017/delivery_dev
      PORT: 3000
    ports:
      - "3000:3000"
    volumes:
      - ./backend:/app
      - /app/node_modules
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      mongodb:
        condition: service_healthy
    command: npm run dev

  # Frontend
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    container_name: delivery-frontend
    environment:
      REACT_APP_API_URL: http://localhost:3000
      CHOKIDAR_USEPOLLING: true
    ports:
      - "3001:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules
    depends_on:
      - backend
    command: npm start

  # MailHog (開発用メールサーバー)
  mailhog:
    image: mailhog/mailhog:latest
    container_name: delivery-mailhog
    ports:
      - "1025:1025"  # SMTP
      - "8025:8025"  # Web UI
    logging:
      driver: none

volumes:
  postgres_data:
  redis_data:
  mongodb_data:
```

**開発環境セットアップ手順**
```bash
# 1. リポジトリクローン
git clone https://github.com/your-org/delivery-system.git
cd delivery-system

# 2. 環境変数設定
cp .env.example .env.local

# 3. Docker コンテナ起動
docker-compose up -d

# 4. データベースマイグレーション
docker-compose exec backend npm run migrate

# 5. シードデータ投入
docker-compose exec backend npm run seed

# 6. アクセス確認
# Frontend: http://localhost:3001
# Backend API: http://localhost:3000
# MailHog: http://localhost:8025
```

**開発時のコマンド**
```bash
# ログ確認
docker-compose logs -f backend

# テスト実行
docker-compose exec backend npm test

# データベースリセット
docker-compose exec backend npm run db:reset

# コンテナ再起動
docker-compose restart backend

# 全コンテナ停止・削除
docker-compose down -v
```

**メリット**
- コスト: 無料（開発者のPC上で完結）
- セットアップ: 5分程度
- ネットワーク: オフライン開発可能
- データ: ローカルで完全管理

**デメリット**
- PCスペック要件が高い
- 他の開発者とのデータ共有が困難
- 本番環境との差異が発生する可能性

#### オプション2: 共有開発環境（AWS軽量構成）

複数の開発者で共有する開発環境。AWSに構築するが、最小構成でコストを抑制。

**AWS構成**
```yaml
環境名: development
AWS Account: 専用アカウント or 共有アカウント
Region: ap-northeast-1
VPC: 10.1.0.0/16

リソース構成:
  VPC:
    パブリックサブネット: 10.1.1.0/24 (1AZのみ)
    プライベートサブネット: 10.1.11.0/24 (1AZのみ)
  
  ECS Fargate (Kubernetes不使用):
    サービス: delivery-backend-dev
    タスク定義: 
      CPU: 512 (.5 vCPU)
      メモリ: 1GB
      コンテナ数: 1
    起動時間: 平日 9:00-22:00 (自動停止でコスト削減)
  
  RDS PostgreSQL:
    インスタンスクラス: db.t3.micro
    ストレージ: 20GB gp2
    Multi-AZ: 無効
    自動停止: 夜間・休日停止
  
  ElastiCache Redis:
    ノードタイプ: cache.t3.micro
    ノード数: 1
    自動停止: 夜間・休日停止
  
  DocumentDB:
    使用しない（MongoDBコンテナで代用）
  
  ALB:
    使用しない（CloudFront + S3で代用）
```

**docker-compose.dev-aws.yml（一部サービスのみローカル）**
```yaml
version: '3.8'

services:
  # MongoDB（DocumentDBの代わりにローカル実行）
  mongodb:
    image: mongo:7
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db

  # ローカルでのフロントエンド開発
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.dev
    environment:
      REACT_APP_API_URL: https://dev-api.delivery-system.example.com
    ports:
      - "3001:3000"
    volumes:
      - ./frontend:/app
      - /app/node_modules

volumes:
  mongodb_data:
```

**Terraform構成（開発環境）**
```hcl
# environments/development/main.tf

module "vpc" {
  source = "../../modules/vpc"
  
  environment = "development"
  vpc_cidr = "10.1.0.0/16"
  availability_zones = ["ap-northeast-1a"]  # 1 AZのみ
  enable_nat_gateway = true
  single_nat_gateway = true  # コスト削減
}

module "rds" {
  source = "../../modules/rds"
  
  identifier = "delivery-db-dev"
  instance_class = "db.t3.micro"
  allocated_storage = 20
  multi_az = false
  backup_retention_period = 0  # バックアップ無効
  skip_final_snapshot = true
  
  # 自動停止スケジュール
  auto_stop_schedule = "cron(0 22 * * ? *)"  # 22:00停止
  auto_start_schedule = "cron(0 9 * * ? *)"  # 9:00起動
}

module "elasticache" {
  source = "../../modules/elasticache"
  
  cluster_id = "delivery-redis-dev"
  node_type = "cache.t3.micro"
  num_cache_nodes = 1
  
  # 自動停止（Lambda関数で実装）
  enable_auto_stop = true
}

module "ecs" {
  source = "../../modules/ecs-fargate"
  
  cluster_name = "delivery-dev"
  service_name = "backend"
  
  task_cpu = 512
  task_memory = 1024
  desired_count = 1
  
  container_definitions = [
    {
      name = "backend"
      image = "${aws_ecr_repository.backend.repository_url}:dev"
      cpu = 512
      memory = 1024
      portMappings = [
        {
          containerPort = 3000
          protocol = "tcp"
        }
      ]
    }
  ]
}
```

**自動起動・停止スケジュール**
```python
# lambda/auto_stop_start.py
import boto3
import os

rds = boto3.client('rds')
elasticache = boto3.client('elasticache')
ecs = boto3.client('ecs')

def lambda_handler(event, context):
    action = event.get('action')  # 'stop' or 'start'
    
    if action == 'stop':
        # RDS停止
        rds.stop_db_instance(DBInstanceIdentifier='delivery-db-dev')
        
        # ECS タスク数を0に
        ecs.update_service(
            cluster='delivery-dev',
            service='backend',
            desiredCount=0
        )
        
        print("Development environment stopped")
    
    elif action == 'start':
        # RDS起動
        rds.start_db_instance(DBInstanceIdentifier='delivery-db-dev')
        
        # ECS タスク数を1に
        ecs.update_service(
            cluster='delivery-dev',
            service='backend',
            desiredCount=1
        )
        
        print("Development environment started")
```

**EventBridge スケジュール**
```json
{
  "schedules": [
    {
      "name": "dev-env-stop",
      "schedule": "cron(0 22 * * ? *)",
      "target": {
        "arn": "arn:aws:lambda:ap-northeast-1:123456789012:function:auto-stop-start",
        "input": "{\"action\": \"stop\"}"
      }
    },
    {
      "name": "dev-env-start",
      "schedule": "cron(0 9 * * MON-FRI *)",
      "target": {
        "arn": "arn:aws:lambda:ap-northeast-1:123456789012:function:auto-stop-start",
        "input": "{\"action\": \"start\"}"
      }
    }
  ]
}
```

**開発環境アクセス方法**
```bash
# 1. AWS CLIで認証
aws sso login --profile dev

# 2. データベース接続（SSM Session Manager経由）
aws ssm start-session --target i-xxxxx --profile dev \
  --document-name AWS-StartPortForwardingSessionToRemoteHost \
  --parameters '{"host":["delivery-db-dev.xxxxx.ap-northeast-1.rds.amazonaws.com"],"portNumber":["5432"],"localPortNumber":["5432"]}'

# 3. バックエンドAPI接続
curl https://dev-api.delivery-system.example.com/health

# 4. ログ確認
aws logs tail /ecs/delivery-backend-dev --follow --profile dev
```

**月額コスト見積もり（共有開発環境）**

| サービス | スペック | 稼働時間 | 月額概算 (USD) |
|---------|---------|---------|---------------|
| ECS Fargate | 0.5 vCPU, 1GB | 13時間/日 × 22日 | $10 |
| RDS (t3.micro) | db.t3.micro | 13時間/日 × 22日 | $8 |
| ElastiCache (t3.micro) | cache.t3.micro | 13時間/日 × 22日 | $6 |
| NAT Gateway | 1台 | 24時間 | $45 |
| S3 | 10GB | 常時 | $1 |
| CloudWatch Logs | 5GB | 常時 | $3 |
| **合計** | | | **約 $73** |

※ 自動停止により、24時間稼働の約30%のコスト

### 10.2 開発環境の比較

| 項目 | ローカル環境 | 共有AWS環境 |
|-----|------------|------------|
| **初期費用** | 0円 | 0円 |
| **月額費用** | 0円 | $73 |
| **セットアップ時間** | 5分 | 30分 |
| **PC要件** | 16GB RAM必須 | 8GB RAMで可 |
| **データ共有** | 困難 | 容易 |
| **本番環境との差異** | 大きい | 小さい |
| **オフライン開発** | 可能 | 不可 |
| **推奨人数** | 1-3人 | 4人以上 |

### 10.3 開発環境の推奨構成

**開発チーム規模別の推奨**

```
1-3人のチーム:
  → ローカル開発環境（Docker Compose）
  理由: コスト0、セットアップ簡単、個人ペースで開発可能

4-10人のチーム:
  → ローカル開発 + 共有AWS環境の併用
  理由: 各自ローカルで開発、統合テストは共有環境

10人以上のチーム:
  → 共有AWS環境（複数インスタンス）
  理由: 環境統一、データ共有、CI/CD統合
```

### 10.4 開発環境のCI/CD

**GitHub Actions ワークフロー（開発環境）**
```yaml
# .github/workflows/deploy-development.yml
name: Deploy to Development

on:
  push:
    branches: [develop]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_DEV }}
          aws-region: ap-northeast-1
      
      - name: Build and push to ECR
        run: |
          aws ecr get-login-password | docker login --username AWS --password-stdin $ECR_REGISTRY
          docker build -t delivery-backend:dev ./backend
          docker tag delivery-backend:dev $ECR_REGISTRY/delivery-backend:dev
          docker push $ECR_REGISTRY/delivery-backend:dev
      
      - name: Update ECS service
        run: |
          aws ecs update-service \
            --cluster delivery-dev \
            --service backend \
            --force-new-deployment
```

### 10.5 開発環境のデータ管理

**テストデータ投入**
```bash
# backend/prisma/seed.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // マスタデータ
  await prisma.branch.createMany({
    data: [
      { branch_id: 'B-001', branch_name: '東京本社', address: '東京都千代田区...' },
      { branch_id: 'B-002', branch_name: '大阪支社', address: '大阪府大阪市...' },
    ]
  });

  // 車両データ
  await prisma.vehicle.createMany({
    data: [
      { vehicle_id: 'V-001', vehicle_number: '品川 123 あ 4567', vehicle_type: '2tトラック' },
      { vehicle_id: 'V-002', vehicle_number: '品川 456 い 7890', vehicle_type: '4tトラック' },
    ]
  });

  // ドライバーデータ
  await prisma.driver.createMany({
    data: [
      { driver_id: 'D-001', driver_name: '山田太郎', license_type: '大型' },
      { driver_id: 'D-002', driver_name: '佐藤花子', license_type: '中型' },
    ]
  });

  console.log('Seed data inserted successfully');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

### 10.6 開発環境のトラブルシューティング

**よくある問題と解決方法**

```
問題1: Docker起動時にポートが競合
解決: docker-compose down; lsof -ti:3000 | xargs kill -9

問題2: データベース接続エラー
解決: docker-compose restart postgres; docker-compose logs postgres

問題3: ホットリロードが動作しない
解決: package.jsonにCHOKIDAR_USEPOLLING=true設定

問題4: メモリ不足
解決: Docker Desktopのメモリ割り当てを8GB以上に増加

問題5: AWS開発環境が停止している
解決: aws lambda invoke --function-name auto-stop-start \
       --payload '{"action":"start"}' response.json
```

## 11. Infrastructure as Code

### 11.1 Terraform

- VPC、サブネット定義
- EKSクラスタ定義
- RDS、ElastiCache定義
- セキュリティグループ定義

### 11.2 Helm Chart

- アプリケーションデプロイ
- 環境別values設定

---

**文書管理情報**
- 文書番号: INFRA-001
- 最終更新日: 2025-01-20
